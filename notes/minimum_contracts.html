<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<style type="text/css">
pre {font-family: "Consolas", "Lucida Console", monospace; margin-left:20pt; }
code {font-family: "Consolas", "Lucida Console", monospace; }
pre > i   { font-family: "Consolas", "Lucida Console", monospace;  font-style:italic; }
code > i  { font-family: "Consolas", "Lucida Console", monospace;  font-style:italic; }
pre > em  { font-family: "Consolas", "Lucida Console", monospace;  font-style:italic; }
code > em { font-family: "Consolas", "Lucida Console", monospace;  font-style:italic; }
body { color: #000000; background-color: #FFFFFF; }
del { text-decoration: line-through; color: #8B0040; }
ins { text-decoration: underline; color: #005100; }

p.example   { margin-left: 2em; }
pre.example { margin-left: 2em; }
div.example { margin-left: 2em; }

code.extract { background-color: #F5F6A2; }
pre.extract  { margin-left: 2em; background-color: #F5F6A2;  border: 1px solid #E1E28E; }

p.function    { }
.attribute    { margin-left: 2em; }
.attribute dt { float: left; font-style: italic;  padding-right: 1ex; }
.attribute dd { margin-left: 0em; }

blockquote.std    { color: #000000; background-color: #F1F1F1;  border: 1px solid #D1D1D1;  padding-left: 0.5em; padding-right: 0.5em; }
blockquote.stddel { text-decoration: line-through;  color: #000000; background-color: #FFEBFF;  border: 1px solid #ECD7EC;  padding-left: 0.5empadding-right: 0.5em; ; }
blockquote.stdins { text-decoration: underline;  color: #000000; background-color: #C8FFC8;  border: 1px solid #B3EBB3; padding: 0.5em; }
table.header { border: 0px; border-spacing: 0;  margin-left: 0px; font-style: normal; }
table { border: 1px solid black; border-spacing: 0px;  margin-left: auto; margin-right: auto; }
th { text-align: left; vertical-align: top;  padding-left: 0.4em; border: none;  padding-right: 0.4em; border: none; }
td { text-align: left;  padding-left: 0.4em; border: none;  padding-right: 0.4em; border: none; }
</style>

<title>Contract Support: Defining the Minimum Viable Feature Set</title>

</head>
<body>

<table class="header"><tbody>
  <tr>
    <th>Document number:&nbsp;&nbsp;</th><th> </th><td>DXXXXr0</td>
  </tr>
  <tr>
    <th>Date:&nbsp;&nbsp;</th><th> </th><td>2020-05-XX</td>
  </tr>
  <tr>
    <th>Audience:&nbsp;&nbsp;</th><th> </th><td>SG21</td>
  </tr>
  <tr>
    <th>Reply-to:&nbsp;&nbsp;</th><th> </th><td><address>Andrzej Krzemie&#324;ski &lt;akrzemi1 at gmail dot com&gt;</address>
	<address>Ryan McDougall</address><address>Joshua Berne</address></td>
  </tr>
</tbody></table>



<h1>Contract Support: Defining the Minimum Viable Feature Set</h1>


    <p>We observe that "C++20 contracts" consisted of two parts. 
	One part was clear, well understood, widely agreed upon, and useful 
	to various groups of C++ users. The other part rose a lot of controversies
	for various reasons and ultimately led to the removal of the entire feature.
	</p>
	
	<p>In paper <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2114r0.html"
    >[P2114r0]</a> we have indicated the use cases that we believe represent the 
	uncontroversial part of "C++20 contracts". If only those were supported in C++
	it would already have a huge positive impact on many diverse groups of users. 
	In this paper we provide the rationale for our choice. We show that our selection:</p>
	
	<ul>
	<li>is big enough to be called a Minimum Viable Product (MVP) and get support of the majority of C++ programmers,</li>
	<li>does not require controversial design, or features not already implemented in other languages,</li>
	<li>does not prevent the addition of any of the remaining features of "C++20 contracts", or other discussed alternatives, in subsequent stages.</li>
	</ul>
	
	

<h2><a name="analysis">Analysis</a></h2>


	<p>In this document we use term <em>C++20 contracts</em> to refer to contract support
	facilities in C++ Standard draft just before the removal: 
	  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/n4820.pdf">[N4820]</a>
          and pieces of the associated proposals that EWG had agreed upon to alter that before
          the removal
          <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1429r3.pdf">[P1429R3]</a>
          and 
          <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/P1607R1.pdf">[P1607R1]</a>
          .</p>
	
    <p><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2076r0.html">[P2076r0]</a> 
    lists the points the disagreements about the previous incarnation of contracts design:</p>

    <ul>
    <li>continuation mode,</li>
    <li>build levels,</li>
    <li>global toggles aka external remapping controls,</li>
    <li>literal semantics aka in-source controls,</li>
    <li>assumption.</li>
    </ul>

    <p>The claim we make here is that if we eliminated from C++ contracts the use cases handled by 
	the above features, or at least reduced them significanly, the remainder would still be a complete
	feature that would offer a great help in enforcing program correctness. The value in preventing bugs
	and enforcing program correcness comes from</p>
	
	<ol type="a">
    <li>being able to express preconditions, postconditions (and similar constraints) as C++ predicates, and</li>
    <li>being able to turn them into runtime-checks: all or none is sufficient granularity to begin
      to be useful and leave open the deasign of finer control to future work.</li>
    </ol>
	
	<p>In the reminder of the paper we elaborate on the features of MVP and show how they map onto use cases
	nominated in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2114r0.html"
    >[P2114r0]</a>. We also discuss how the support for the remaining use cases can be added atop of MVP
    in subsequent phases of adding contract support to C++.</p>



<h3><a name="analysis.going_in">Features in MVP</a></h3>


<h4><a name="analysis.going_in.declarations">Contract declarations</a></h4>

    <p>The most important thing is the ability to express the predicates in function declarations 
	as compiler-checked C++ expressions. This is uncontroversial. This enables: </p>
    
    <ul>
    <li>compiler to report type-system errors from incorrectly spelled constraints,</li>
    <li>generation of run-time code, such as contract checks, or unit tests,</li>
    <li>certain forms of static analysis.</li>
    </ul>
    
    <p>In fact, this feature alone would already satisfy many users.</p>
    
    <p>Use cases covered:</p>
    
    <ul>
    <li><code>dev.reason.knowl</code></li>
    <li><code>dev.readable.syntax</code></li>
    <li><code>dev.readable.keywords</code></li>
    <li><code>dev.parsable</code></li>
    <li><code>dev.tooling</code></li>
    <li><code>cppdev.syntax.familiar</code></li>
    <li><code>cppdev.syntax.cpp</code></li>
    <li><code>cppdev.syntax.reuse</code></li>
    <li><code>cppdev.location</code></li>
    <li><code>api.communicate.inputsoutputs</code></li>
    <li><code>api.establish.preconditions</code></li>
    <li><code>api.establish.postconditions</code></li>
    <li><code>api.express.values</code></li>
    <li><code>api.contract.errorhandling</code></li>
    <li><code>arch.nomacros</code></li>
    <li><code>arch.complete</code></li>
    <li><code>sdev.bestpractices</code></li>
    <li><code>jdev.understand.contracts</code></li>
    <li><code>jdev.understand.keywords</code></li>
    <li><code>adev.fast</code></li>
    <li><code>teach.bestpractices</code></li>
    <li><code>teach.standardized</code></li>
    <li><code>teach.portable</code></li>
    </ul>
    
    
	
    
<h4><a name="analysis.going_in.on_off">Turning on and off all runtime checks</a></h4>

    <p>Another MVP requirement manifests in the following set of essential, but self-contradictory requirements.</p>
    
    <ol>
        <li>A guarantee that program never continues after a contract predicate is violated.</li>
        <li>A guarantee that not a single runtime instruction is generated from my contract declarations.</li>
    </ol>
    
    <p>This suggests that there needs to be at least one two-state flag that toggles between:
    "only syntax-check" and "inject run-time checks." For MVP it is enough to do what 
    <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0542r5.html">[P0542r5]</a> offered: only require of
    implementations that they allow building <em>all</em> translation units in the same mode. Any finer-grained control
    is implementation defined.</p>
    
    <p>Use cases covered:</p>
    
    <ul>
    <li><code>dev.reason.sideeffects</code></li>
    <li><code>int.conform.postconditions</code></li>
    <li><code>int.control.build</code></li>
    <li><code>int.runtime.unchecked</code></li>
    <li><code>qdev.checkall</code></li>
    </ul>
    
    
<h4><a name="analysis.going_in.logging">Reporting contract violation</a></h4>


    <p>On platforms where it makes sense, each contract violation detected at run-time should 
    be reported to the users (what failed, where in the source code).</p>
    
    <p>Use cases covered:</p>
    
    <ul>
    <li><code>api.establish.check</code></li>
    <li><code>api.establish.values</code></li>
    <li><code>int.conform.violation</code></li>
    <li><code>int.violations.information</code></li>
    <li><code>jdev.understand.violations</code></li>
    <li><code>jdev.understand.aborting</code></li>
    <li><code>jdev.understand.buildviolation</code></li>
    </ul>
    
    
 <h4><a name="analysis.going_in.custom_handler">Customizing how failures are reported</a></h4>
 
 
    <p>Should programmers be in control how the logging of a failed contract runtime check is performed? 
    Again, for the MVP, we think that 
    <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0542r5.html">[P0542r5]</a> got that right:
    implemenations are not required to offer this, but they can if they choose to.</p>
    
    
	<p>Use cases covered (implementation defined):</p>
    
    <ul>
    <li><code>int.violations.common</code></li>
    </ul>
    

<h3><a name="analysis.stayng_out">Features not in MVP</a></h3>



<h4><a name="analysis.stayng_out.continuation">Continuation after failed run-time check</a></h4>
    

    <p>The use case that continuation mode was trying to address are <code>sdev.maturity</code>
    and </code>large.newcompiler</code>. They can be introduced on top of MVP as annotations
    on individual contract declarations (as described in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1332r0.txt"
    >[P1332r0]</a>), and additionally requireing more build modes.</p>
    
    
    
<h4><a name="analysis.stayng_out.levels">Contract levels</a></h4>

    <p>The use cases that contract levels, such as <code>default</code> and <code>audit</code>, tried to address
    are <code>crit.more.coverage</code>, <code>dev.reason.cost</code> and <code>crit.production.checking</code>. The goal was to
    indicate "this predicate is more expensive to evaluate than the function it protects",
    but the design of this feature had flaws:
    </p>
	
	<ul>
	<li>Syntax cannot handle templates where the level may depend on template arguments.</li>
	<li>Two levels (or even three) cannot be enough.</li>
	<li>Levels is not enough to convey essential meta information.</li>
	<li>Syntax is not extensible.</li>
	<li>Syntax is uncomfortable.</li>
	</ul>
    
    <p>They can be introduced on top of MVP as annotations indicating how expensive a contract statement is relative to 
    the body of the function.</p>
    
   
  
<h4><a name="analysis.stayng_out.build_levels">Global toggles aka external remapping controls</a></h4>


    <p>If there are no levels in contract declarations in the MVP, there is no need for having build
    levels either, other than on/off switch. They can be added later if needed.</p>
    
 

<h4><a name="analysis.stayng_out.literal_semantics">Literal semantics aka in-source controls</a></h4> 


    <p>They were never in the draft, but were discussed widely. There were concerns rised that (1)
    they would encourage the use of macros (2) counter to what was claimed, they were not basic building blocks 
    from which C++20 (as in<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0542r5.html"
      >[P0542r5]</a>) could be built. They can be added atop of MVP by adding meta-information to contract 
    declarations.</p>


 
<h4><a name="analysis.stayng_out.assumptions">Assumptions or injected facts</a></h4>
 
 
	<p>This was highly controversial. Some of them were captured in 
    <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2064r0.pdf">[P2064r0]</a>.
    Use cases covered: <code>pdev.footgun</code> and <code>hardware.performance</code>.</p>
    
    <p><code>pdev.footgun</code> can be handled by a separate feature, such as 
    <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1774r3.pdf">[P1774r3]</a>.
    Alternatively, it could be implemented atop of MVP by adding special meta-information to 
    individual contract declarations.</p>
    
    <p><code>hardware.performance</code> could be implemented atop of MVP by introducing a yet another
    build mode. Alternatively, users could achieve it with MVP by installing a custom
    violation handler with <code>__builtin_unreachable()</code>.</p>
	


<h4><a name="analysis.stayng_out.axioms">Indicating inexpressible predicates</a></h4>


    <p>This woud cover use cases <code>qdev.tooling.control</code> and
    <code>api.express.unimplementable</code>. Controversies arose because of mixng
    inexpressibility with levels, and taking word "axiom" to mean <code>__builtin_assume()</code>.</p>
    
    <p>Can be implemented atop of MVP either as meta-information on contract declarations, or
    by annotating functions as inexpressible as described in
    <a href="https://isocpp.org/files/papers/P2176R0.html">[P2176r0]</a>.</p>
    
 
 
<h2><a name="conclusion">Conclusion</a></h2>
 
 
	<p>Is the MVP too small? It certainly misses important use cases. But we believe that even the MVP
    contains a number of unresolved small issues that will require time to polish. They were not 
    given sufficient consideration for C++20 because the controversial bits took nearly all the 
    attention of EWG. If we are to ship any contract programming support in C++23 time frame,
    we have to be sure that we have a small enough scope to be accomodated by the WG21 process.</p>

    <p>On the other hand,
    the biggest advantage of MVP is that we provide a standard notation for expressing
    preconditions and postconditions. This notation will be consumed by many tools, which are not
    necessarily compilers. The positive effect on the community is not necessarily in what compilers
    can do with it, but also what other automated tools can get from it. This is far beyond the
    scope of the C++ Standard.</p>


<h2><a name="literature">References</a></h2>

<ul>

    <li>[P2114r0] &mdash; Joshua Berne, Ryan McDougall, Andrzej Krzemieński, 
    "Minimal Contract Use Cases" <br />
    (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2114r0.html"
    >http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2114r0.html</a>).    
    </li>
    
	<li>[N4820] &mdash; Richard smith, "Working Draft, Standard for Programming Language C++",<br />
	<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/n4820.pdf"
	>http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/n4820.pdf</a>).
	</li>
	
    <li>[P0542r5] &mdash; G. Dos Reis, J. D. Garcia, J. Lakos, A. Meredith, N. Myers, B. Stroustrup,
      "Support for contract based programming in C++" <br />
      (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0542r5.html"
      >http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0542r5.html</a>).
      </li>

    <li>[p2076r0] &mdash; Ville Voutilainen, "Previous disagreements on Contracts" <br />
    (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2076r0.html"
    >http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2076r0.html</a>).</li>
    
    <li>[P1774r3] &mdash; Timur Doumler, "Portable assumptions" <br />
    <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1774r3.pdf"
    >http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1774r3.pdf</a>).</li>
    
    <li>[P1332r0] &mdash; Joshua Berne, Nathan Burgers, Hyman Rosen, John Lakos,
    "Contract Checking in C++: A (long-term) Road Map" <br />
    (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1332r0.txt"
    >http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1332r0.txt</a>).
    </li>
     
	<li>[P1517r0] &mdash; Ryan McDougall, "Contract Requirements for Iterative High-Assurance Systems" <br>
    (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1517r0.html"
    >http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1517r0.html</a>).
    </li>
	
    <li>[P2176r0] &mdash; Andrzej Krzemieński, "A different take on inexpressible conditions" <br>
    (<a href="https://isocpp.org/files/papers/P2176R0.html"
    >https://isocpp.org/files/papers/P2176R0.html</a>).
    </li>
    
    <li>[P2064r0] &mdash; Herb Sutter, "Assumptions" <br>
    (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2064r0.pdf"
    >http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2064r0.pdf</a>).
    </li>
	
	<li>[P2038r0] &mdash; Andrzej Krzemieński, Ryan McDougall,
	"Proposed nomenclature for contract-related proposals" <br />
    (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2038r0.html"
    >http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2038r0.html</a>).
    </li>
	
	<li>[N4160] &mdash; Andrzej Krzemieński, "Value Constraints" <br>
    (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4160.html"
    >http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4160.html</a>).
    </li>
	
	<li>[P1344r1] &mdash; Nathan Myers, "Pre/Post vs. Enspects/Exsures" <br>
    (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1344r1.md"
    >http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1344r1.md</a>).
    </li>
	
    
</ul>

<!-- http://wiki.edg.com/pub/Wg21summer2020/CoreWorkingGroup/cwg_closed.html#2296 -->
<!-- http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0348r0.html -->

</body>
</html>
