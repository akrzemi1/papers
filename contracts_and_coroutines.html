<!DOCTYPE html>
<html lang="en"><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<style>
pre {font-family: "Consolas", "Lucida Console", monospace; margin-left:20pt; }
code {font-family: "Consolas", "Lucida Console", monospace; }
pre > i   { font-family: "Consolas", "Lucida Console", monospace;  font-style:italic; }
code > i  { font-family: "Consolas", "Lucida Console", monospace;  font-style:italic; }
pre > em  { font-family: "Consolas", "Lucida Console", monospace;  font-style:italic; }
code > em { font-family: "Consolas", "Lucida Console", monospace;  font-style:italic; }
dl > dt { font-style:italic; }
body { font-family: "Calibri" }

@media (prefers-color-scheme: dark) {
	body { background: #111; color:  #ccc; }
	a { color:  #38f; }
	a:visited { color:  #a4d; }
	.sect { color:  #ccc; }
    del { text-decoration: line-through; color: #EE9999; }
    ins { text-decoration: underline; color: #99EE99; }
    blockquote.std    { color: #ccc; background-color: #2A2A2A;  border: 1px solid #3A3A3A;  padding-left: 0.5em; padding-right: 0.5em; }
    blockquote.stddel { text-decoration: line-through;  color: #ccc; background-color: #221820;  border: 1px solid #332228;  padding-left: 0.5em; padding-right: 0.5em; ; }
    blockquote.stdins { text-decoration: underline;  color: #ccc; background-color: #182220;  border: 1px solid #223328; padding: 0.5em; }
    table { border: 1px solid #ccc; border-spacing: 0px;  margin-left: auto; margin-right: auto; }
}

@media (prefers-color-scheme: light) {
	body { background:  white; color: black; }
    del { text-decoration: line-through; color: #8B0040; }
    ins { text-decoration: underline; color: #005100; }
    blockquote.std    { color: #000000; background-color: #F1F1F1;  border: 1px solid #D1D1D1;  padding-left: 0.5em; padding-right: 0.5em; }
    blockquote.stddel { text-decoration: line-through;  color: #000000; background-color: #FFEBFF;  border: 1px solid #ECD7EC;  padding-left: 0.5em; padding-right: 0.5em; ; }
    blockquote.stdins { text-decoration: underline;  color: #000000; background-color: #C8FFC8;  border: 1px solid #B3EBB3; padding: 0.5em; }
    table { border: 1px solid black; border-spacing: 1px;  margin-left: auto; margin-right: auto; }
}


.comment em { font-family: "Calibri"; font-style:italic; }
p.example   { margin-left: 2em; }
pre.example { margin-left: 2em; }
div.example { margin-left: 2em; }
div.poll { margin-left: 2em; }

code.extract { background-color: #F5F6A2; }
pre.extract  { margin-left: 2em; background-color: #F5F6A2;  border: 1px solid #E1E28E; }

p.function    { }
.attribute    { margin-left: 2em; }
.attribute dt { float: left; font-style: italic;  padding-right: 1ex; }
.attribute dd { margin-left: 0em; }

.editor { color: #4444BB; font-style: normal; background-color: #DDDDDD; }

tab { padding-left: 4em; }
tab3 { padding-left: 3em; }

.link { float: right; font-family: "Consolas", "Lucida Console", monospace; font-size:80% }


table.header { border: none; border-spacing: 0;  margin-left: 0px; font-style: normal; }
td.header { border: none; border-spacing: 0;  margin-left: 0px; font-style: normal; }
.header { border: none; border-spacing: 0;  margin-left: 0px; font-style: normal; }
table.poll { border: 1px solid black; border-spacing: 0px;  margin-left: 0px; font-style: normal; }

th { text-align: left; vertical-align: top;  padding-left: 0.4em;  /*padding-right: 0.4em; border-bottom:1px dashed;*/ }
td { text-align: left;  padding-left: 0.4em; padding-right: 0.4em; /*border-right:1px dashed; */}
tr { border: solid; border-width: 1px 0; border-bottom:1px solid blue }


.revision   { /*color: #005599;*/ }
.grammar { list-style-type:none }

</style>

<title>Contracts and coroutines</title>

</head>
<body>  

<table class="header"><tbody>
  <tr>
    <th>Document number:&nbsp;&nbsp;</th><th> </th><td class="header">D2957R2</td>
  </tr>
  <tr>
    <th>Date:&nbsp;&nbsp;</th><th> </th><td class="header">2024-09-17</td>
  </tr>
  <tr>
    <th>Audience:&nbsp;&nbsp;</th><th> </th><td class="header">SG21</td>
  </tr>
  <tr>
    <th>Reply-to:&nbsp;&nbsp;</th><th> </th><td class="header">
        <address>Andrzej Krzemie&#324;ski &lt;akrzemi1 at gmail dot com&gt;</address>
        <address>Iain Sandoe &lt;iain at sandoe dot co dot uk&gt;</address>
    </td>
  </tr>
</tbody></table>



<h1>Contracts and coroutines</h1>


<p> This paper proposes how preconditions and postconditions should interact with
    coroutines. </p>

<p> Coroutines generalise regular functions in a specific manner: control can
    return to the caller even though the function body has not finished executing.
    This gives rise to some doubts as to whether the semantics of postconditions,
    as defined for regular functions, still apply. </p>


<h2>Revision History</h2>

<h3>R1</h3>

<ul>
    <li>Now proposing that it is unspecified whether preconditions see the function
        parameters before the copying of parameters or the copies of the parameters.</li>
    <li>No longer proposing postconditions on coroutines.</li>
</ul>

<h3>R2</h3>

<ul>
    <li>Now requiring that preconditions see the function parameters
        before they are copied to the coroutine frame.</li>
    <li>Now proposing that postconditions on coroutines be allowed, 
        but make it ill-formed when they reference function parameters.</li>
    <li>We now have a reference implementation in GCC.</li>
    <li>We are now highlighting the property of a postcondition relevant to the
        discussion of coroutines: that it applies at the point where the callee
        has finished and the caller is resumed.</li>
    <li>Demonstrated how <em>parameter captures</em> can enable referring 
        to coroutine parameters in postconditions in the future.</li>
    <li>Expanded the argumentation as to why the inability to express coroutine-
        specific complicated guarantees should not hold back the addition of well
        understood preconditions and postconditions.</li>        
</ul>


<h2>Executive summary</h2>

<p> We start by observing the following properties of coroutines in C++.</p>

<ol>
  <li>Coroutines are functions (even if with special properties).</li>
  <li>In a place where a function is called, one cannot tell if the called
      function is a coroutine or not.</li>
</ol>

<p> Further, we use the following definitions of preconditions and postconditions
    that do not refer to function bodies.
</p>

<ol>
  <li><em>Precondition</em> &mdash; what the caller needs to provide in order
          for the function call to be correct.</li>
  <li><em>Postcondition</em> &mdash; what the caller is guaranteed to receive
          from a correct (no bugs) and successful (no exceptions) function call.</li>
</ol>

<p> From this we derive two conclusions: </p>

<ol>
  <li>Given that contracts are used to monitor the correctness of function calls, 
      this ability should not be arbitrarily hampered by disallowing the contract 
      assertions on some function declarations.</li>
  <li>There is only one possible point when postconditions are evaluated: 
      when the function call ends and the control is returned to the 
      caller.</li>
</ol>

<p> The design is clear. What remains is addressing implementation difficulties.</p>



<h2> Coroutine properties </h2>

<p> A regular function <em>definition</em> becomes a coroutine when one of the
    '<code>co_</code>' keywords is encountered in its body.
    Thus one cannot tell if a function is a coroutine from either its declaration
    or invocations, for example:</p>

<pre>
awaitable&lt;int&gt; session(int id); <em>// may be a coroutine, may be a function</em>

awaitable&lt;int&gt; default_session()
{
  awaitable&lt;int&gt; s = session(0); <em>// maybe invoking a coroutine, maybe a function</em>
  return s;
}
</pre>

<p> In this example, since we have the function body, we can see that
    <code>default_session</code> is a regular function even though it returns an
    <em>Awaitable</em>.  We know less about <code>session</code>: it could also
    be a factory function, like <code>default_session</code>, or it could be a
    coroutine.</p>

<p> When we invoke a coroutine, from the caller's perspective it behaves as a
    factory function for creating a <em>coroutine return object</em> (current
    implementations call this factory function a "<em>ramp function</em>").
    Such a <em>ramp function</em> can surely have a contract.
    For instance, <code>session</code> could require that the passed <code>id</code>
    has a non-negative value. </p>

<p> An important difference between regular functions and coroutines, is that
    when the callee returns control to the caller, for a regular function all
    automatic state of the function is complete; conversely, for a coroutine
    that has suspended, some or all of that state (and parameter values) might
    have been captured in preparation for a potential resumption.
    Similarly, observable side-effects of a coroutine can (and most likely will)
    change at some arbitrary point after the dialogue with the caller has
    concluded.
    Thus, when the <em>ramp function</em> (the call to <code>session(id)</code>
    above) returns, and has produced a <em>coroutine return object</em>, we might
    have expectation of some sub-set of state of this return object but, in
    general, that could be more limited than the expectations applicable to a
    regular function. </p>    


<h3> Copies of function parameters </h3>

<p> Another property specific to coroutines is that when the coroutine is invoked
    the function parameters are <em>copied</em> into the coroutine frame
    <a href="http://eel.is/c++draft/dcl.fct.def.coroutine#13">[dcl.fct.def.coroutine]/13</a>:</p> 
    
<blockquote>For a parameter of type <em>cv</em> <code>T</code>, 
    the copy is a variable of type <em>cv</em> <code>T</code> 
    with automatic storage duration that is direct-initialized 
    from an xvalue of type <code>T</code> referring to the parameter.
    </blockquote>
    
<p> This gives rise to the most significant challenge for postcondition use of
    parameters since the direct-initialization specified can result in a parameter
    being <b><em>moved</em></b> from which means that the original parameter would no
    longer in the passed state at the conclusion of the ramp. Furthermore, this
    can happen even if a function parameter is declared <code>const</code>.</p>

<h2> Precondition and postcondition properties </h2>


<p> Preconditions and postconditions describe the contract between the caller
    and the callee.  These notions assume the <em>sequential</em> program flow,
    where we have two characteristic points:</p>
    
<ol>
   <li>The caller suspends and the callee starts.</li>
   <li>The callee <strong>finishes</strong> and the caller resumes.</li>
</ol>

<p> A precondition is associated with the first point while a postcondition with
    the second.  An important thing to observe with the second point is that when
    the caller is resumed the callee has finished. Only then can we talk about a
    postcondition: the callee finished (successfully) and therefore it delivered
    the promise to the resumed caller.  The caller needs the postcondition to be
    satisfied by the callee, because it is likely a precondition  of the next
    functions called by the caller:
    </p>  
    
<pre>
awaitable&lt;int&gt; cancelable_session(int id) 
  post (r: is_cancelable(r));
  
template &lt;typename T&gt;
void manage(awaitable&lt;T&gt; session)
  pre (is_cancelable(session));
  
void test()
{
  awaitable&lt;int&gt; session = cancelable_session(1);
  <em>// I need guarantee that</em> is_cancelable(session) <em>is</em> true
  <em>// to make sure that I am calling</em> `manage` <em>in contract </em>
  manage(session);
}
</pre>

<p> The caller is only aware of the callee signature: not its body (or
    implementation).  A caller does not and cannot know whether it is calling a
    coroutine or a regular function. </p>

    

<h2> Preconditions on coroutines </h2>


<p> Preconditions on coroutines are quite intuitive since the call to a coroutine
    is sequential: we have the point where the caller initializes function parameters,
    is suspended and the callee starts.
    </p>
    
<p> However, in contrast to a regular function, we specify additional actions
    that take place when a coroutine is started, specifically:</p>

<ol>
  <li> Possible allocation of a coroutine state frame
       <a href="http://eel.is/c++draft/dcl.fct.def.coroutine#9">[dcl.fct.def.coroutine]/9</a>
       which might involve a user-supplied allocator that is permitted to read
       the values of coroutine parameters <em>as passed</em>.</li>
  <li> Copying (<b><em>potentially moving</em></b>) of the coroutine parameters
       into the coroutine state frame.</li>
  <li> The initialization of the coroutine promise object, which may pass the
       parameter <em>copies</em> as arguments to the constructor of the promise
       object 
       <a href="http://eel.is/c++draft/dcl.fct.def.coroutine#5.7">[dcl.fct.def.coroutine]/5.7</a>.</li>
</ol>
    
<p> Given that even the allocation of the coroutine frame potentially relies on
    the values of coroutine parameters, this dictates where the precondition
    evaluation should be sequenced: before the allocation of the coroutine frame.
    </p>


<p> <a href="http://eel.is/c++draft/dcl.fct.def.coroutine">[dcl.fct.def.coroutine]</a> specifies that a coroutine behaves as if its
     <code><em>function-body</em></code> were replaced by:</p>
    
<pre>
{
  <em>promise-type</em> <em>promise</em> <em>promise-constructor-arguments</em>;
  try {
    co_await <em>promise</em>.initial_suspend();
    <em>function-body</em>
  } catch ( ... ) {
    if (!<em>initial-await-resume-called</em>)
      throw ;
    <em>promise</em>.unhandled_exception();
  }
<em>final-suspend</em>:
  co_await <em>promise</em>.final_suspend();
}
</pre>

<p> This shows that a number of actions happen in the invoked coroutine before its 
    <code><em>function-body</em></code> is reached. A precondition must be evaluated
    before these actions. Therefore, a correct implementation cannot evaluate the
    coroutine preconditions as a first instruction in its
    <code><em>function-body</em></code>. </p>

<p> Note that, in <code><em>function-body</em></code> above, uses of parameters
    actually refer to the state frame copies, not the originals.
    Thus, the name <code>p</code> of a coroutine parameter denotes a different
    object inside a precondition predicate and the <code><em>function-body</em></code>:
    </p>

<pre>
Awaitable coro(P p)
  pre(is_stack_address(&amp;p))       <em> // likely true</em>
{
  co_return is_stack_address(&amp;p); <em> // likely false</em>
}
</pre>
   
<p> This means that for the "misbehaving" types (where the move constructed
    state is different than the state of the original object before the move) the 
    precondition will see different states of the objects than what the function
    body will see.
    </p>

<p> The following shows a motivating use case for preconditions on coroutines.</p>

<pre>
generator&lt;int&gt; sequence(int from, int to)
  pre (from &lt;= to);
  </pre>


<h2> Postconditions on coroutines </h2>

<p> Postconditions on coroutines are more challenging to define. This is because,
    unlike in regular functions, the resumption of the caller and the ending of
    the coroutine happen potentially at two different points in time: the control
    and the return value is returned to the caller, but the coroutine may be
    suspended, and resumed, via the coroutine handler, much later when the caller
    no longer exists. </p>
    
<p> In normal functions, a postcondition often talks about a return value, which
    is notionally provided to the caller as the last logical action of the function
    body. It is natural to expect that the postcondition is established at this point.
    That is, "What happens at the end of the function" (1) and "what happens when the
    control returns to the caller" (2) are the same thing.
    We need to keep in mind, that for a coroutine, (2) does not necessarily imply
    (1) and thus that we may only make use of properties of the returned value,
    and not of any expected completion of side-effects or destruction of state.</p>

<p> From the perspective of the declared interface to a coroutine, the return
    type is clear and referring to it in a post-condition is reasonable.  Note
    that in the implementation of the coroutine body, the provision of the
    <em>coroutine return object</em> is implicit (there is no corresponding
    user-authored statement for its return).</p>
    
<p> Before we propose the desired semantics, we need to highlight two things:
    one is a property of asynchronous computations in general, the other is
    specific to C++ coroutines.
    </p>

<p> In an asynchronous call, the caller, by definition, is not interested in the
    results of the asynchronous operation <var>A</var>.  The caller will not
    obtain the return value (if any) from <var>A</var>. The caller will not be
    informed if <var>A</var> succeeded or failed. The caller only fires
    <var>A</var> and forgets about it. <var>A</var> only communicates its results
    via some global state, or callbacks.  Thus, whatever happens at the end of
    <var>A</var> is of no interest to the caller. Contrast this with the
    properties of the postcondition: it is a guarantee given
    <em>to the caller</em>, so that the caller can satisfy the preconditions of
    subsequent operations that it calls <em>sequentially</em>.
    </p>

<p> However, every asynchronous operation consists of a small initial sequential
    part, like putting a task onto an asynchronous task queue, or calling the
    <em>ramp function</em> of the coroutine (creating the coroutine frame,
    storing a handle to it, evaluating the coroutine body until the first
    suspension, and building the return object). The caller may want to know if
    this part succeeded; "Did I manage to launch the asynchronous operation?"
    This is a guarantee for the caller that qualifies for a postcondition:
    it may affect the decisions of the caller.
    </p>
    
<p> In the following example, the caller starts a coroutine, only passes its
    handle to someone else, but is not interested in how the coroutine ended,
    and, in fact, the caller ends before the coroutine is resumed. Yet, the
    caller is interested in how the synchronous portion of the coroutine (the
    ramp function) ended:</p>

<pre>
awaitable&lt;int&gt; cancelable_session(int id) 
  post (r: is_cancelable(r));
  
void caller()
{
  awaitable&lt;int&gt; s = cancelable_session(1);
  contract_assert (is_cancelable(s));
  global_cancelable_sessions.push(std::move(s));
}
</pre>

<p> In principle, "the sequential part" of a coroutine can also depend on the
    conditions that are found when each possible suspension point is
    evaluated; that is, a coroutine could validly execute completely synchronously. </p>
    
<p> Given that a coroutine might suspend and resume multiple times, we might
    consider that we want to know what happened at each of the 'end'-points.
    Such 'end'-points are governed by a series of customisation actions in the
    promise and awaiter types and we have two immediate options:</p>

<ol>
   <li>Within the coroutine body code we might use <code>contract_assert</code>
       to verify expected conditions.</li>
   <li>The customisation actions are just regular methods which can be annotated
       with contracts in their own right.</li>
</ol>

<p> It is expected that a significant number of use-cases will involve user-authored
    code that might make use of promise and awaiter implementations provided by
    some external framework.  This is somewhat antagonistic to the second approach
    above; but even there, the first remains viable.</p>

<p> As noted previously, a postcondition is something related to the caller, and the only thing that the caller sees
    is the function declaration and the invocation of the function. The caller does not see the function body, so it has no way of knowing
    if it is invoking a coroutine or a regular function. The implementation should be able to verify the declared postcondition by invoking the predicate
    in the caller immediately after the ramp function finishes:
    </p>
 
<pre>
awaitable&lt;int&gt; cancelable_session(int id) 
  post (r: is_cancelable(r));
  
void caller()
{
  awaitable&lt;int&gt; s = cancelable_session(1);
  <em>// should be able to verify the postcondition here</em>
  <em>// ... </em>
}
</pre> 

<p> Therefore, if we maintain that a postcondition is a guarantee given
    <em>to the caller</em>, the postconditions on coroutines are conceptually
    sound and can have <em>only one meaning</em>: they express the desired state
    of the program immediately after invoking the ramp function of the coroutine.
    More formally, the evaluation of the coroutine postcondition is sequenced
    immediately after the initialization of the result object of a call to a
    coroutine. The evaluation of the postconditions is unsequenced with respect
    to the destruction of the coroutine local state. 
    </p>

<p> (Note that "the initialization of the result object of a call to a coroutine"
    is not the same as the call to <code><em>promise</em>.get_return_object()</code>. 
    The latter happens earlier, and is followed by the call to
    <code>inital_suspend</code>. In the extreme case the type of "the
    initialization of the result object of a call to a coroutine" can be some
    <code>X</code>, whereas
    <code>decltype(<em>promise</em>.get_return_object())</code> can be some
    other type <code>Y</code>, only convertible to <code>X</code>, and in that
    case the postcondition must refer to type <code>X</code> because this is the
    only type that the caller sees.)</p>

<p> In other words, the only consistent semantics for precondition and postcondition
    annotations in coroutines is that they should have the same behavior (modulo
    copies of arguments and the returned value) as if the call to the coroutine
    was wrapped into a factory forwarding function with analogous contract
    annotations:</p>
    
<pre>
awaitable&lt;int&gt; f1(int i)  <em>// coroutine</em>
  pre (p(i))
  post (r: q(r));
  
awaitable&lt;int&gt; f2(int i); <em>// coroutine</em>

awaitable&lt;int&gt; ff2(int i)
  pre (p(i))
  post (r: q(r));
{
  return f2(i);
}
  
void caller()
{
  f1(1);  <em>// these two calls have analogous</em>
  ff2(1); <em>// precondition and postcondition semantics</em>
}
</pre>


<p> A concern has been raised that the author of a coroutine function like
    this one</p>

<pre>
task&lt;int&gt; fun(int&amp; obj)
  <em>// postcondition: obj &gt;= 0</em>
{
  <em>// ...</em>
  obj = 1;
  co_return;
}
</pre>

<p> when they are inexperienced with coroutines, might mistakenly think that 
    the postcondition applies after the <code>co_return</code> statement.
    </p>


<h3>Moved-from function parameters</h3>

<p> However, there is an implementability issue here, stemming from the specifics
    of C++ coroutines: at the point where the postcondition needs to be evaluated,
    function parameters have been moved from (during the copying of function
    parameters in 
    <a href="http://eel.is/c++draft/dcl.fct.def.coroutine#13">[dcl.fct.def.coroutine]/13</a>)
    into the coroutine frame.
    They may be moved from even if they are declared <code>const</code>. Their
    copies are present in the coroutine frame, but if the postcondition is
    implemented on the caller side, the caller has no access to the coroutine
    frame; in fact, the caller may not know that it is dealing with a coroutine.
    In that case the postcondition assertion would be accessing the moved-from
    objects.
    </p>
    
<p> This problem applies only to non-reference function parameters. Passing a
    reference parameter to a coroutine already implies that the referenced object
    has to outlive the coroutine, and the moving a reference parameter is trivial.
    </p>

<p> While there is no way to just make it work nicely, there is a number of
    solutions to remove runtime surprises while still offering some benefits of
    postconditions.</p>
    
<ol>

<li>When a non-reference coroutine parameter <code>p</code> is referenced in a
    postcondition, <code>p</code> should be copied rather than moved to the
    coroutine frame upon starting the coroutine.</li>
    
<li>Make it ill-formed when a coroutine postcondition assertion accesses a
    non-reference coroutine parameter.</li>

</ol>

<p> The first solution has a consequence surprising to the users: adding a
    postcondition assertion may silently change a cheap move operation into an
    expensive copy operation.  For this reason we do not treat option one as viable.
    </p>

<p> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2461r1.pdf"
       title="Gašper Ažman, Caleb Sunstrum, Bronek Kozicki, &ldquo;Closure-Based Syntax for Contracts&rdquo;">[P2461R1]</a>
    proposes a future addition to postcondition assertions that allow the user
    to capture (copy) function parameters upon the function entry, so that these
    copies are available when evaluating the postcondition expression upon
    function return. Referring to such captures is safe, and the copying would
    be explicit. This would enable the postconditions to refer to coroutine
    parameters:</p>

<pre>
generator&lt;int&gt; sequence(int from, int to)
  pre (from &lt;= to)
  post[from, to] (g : g.size() == to - from + 1);
  </pre>



<h2> Coroutine-specific guarantees </h2>


<p> Coroutines, due to their unique nature, may require different kinds of
    guarantees to be expressed. </p>
 
 

<h3>Program state when coroutine finishes normally</h3>
 
    
<p> One such guarantee has already been mentioned:
    what happens when the coroutine is finished in a natural manner: not via an
    exception, not via canceling the coroutine with <code>.destroy()</code>.
    This, in fact could be expressed with an ordinary <code>contract_assert</code>
    at the end of the coroutine scope, assuming that it has a single exit point.
    Otherwise, a new declaration would have to be invented:</p> 
  
<pre>
awaitable&lt;void&gt; seq(State& s) 
{
  <strong>co_post</strong> (s.done()); <em>// guaranteed at the end of coroutine body</em>
  <em>// coroutine body</em>
}
</pre> 

<p> This declaration would not be exposed to the callers, as it does not affect
    the caller.  The point where it is evaluated is unsequenced with respect to
    anything in the caller.</p>

<p> We are not proposing that, or anything else from this section at this point.
    This is only to indicate a possible future direction,
    composable with regular post- and pre-conditions.</p>  
    
    
<h3>What values the returned <em>Awaitable</em> can produce</h3>


<p> Another suggested guarantee is that for the following declaration:</p>

<pre>
awaitable&lt;int&gt; read();
</pre>

<p> We want to specify that the value resulting from <code>co_await</code>ing
    on the returned <em>Awaitable</em> satisfies a certain constraint.
    While conceivable, note that this guarantee is not specific to coroutines.
    In the above declaration, <code>read</code> need not be a coroutine, but
    one might still need to express the same <code>co_await</code>-guarantee.
    Also, consider this example:</p>
    
<pre>
awaitable&lt;void&gt; test(awaitble&lt;int&gt;&amp; aa)
{
   int i = co_await aa; <em>// how to guarantee anything?</em>
   co_yield i + 1;
}
</pre>

<p> Here, we might want to have a guarantee that <code>aa</code> yields only
    certain values, but there is no coroutine in sight that would be making
    this guarantee. Such a guarantee would have to be a property of the
    <em>Awaitable</em>.</p>
    
<p> Even if the coroutine were in sight, enforcing such a guarantee would be
    difficult.  When a coroutine yields a value, this value is never seen
    directly by the consumer. It is first passed to function
    <code>yield_value</code>, then there may be an arbitrary number of
    additional functions processing the value, depending on the implementation
    of the promise type and the <em>Awaitable</em>, and then
    <code>operator co_await</code> is invoked.  Each of these functions can
    arbitrarily change the original value, so that the value yielded by the
    coroutine may be arbitrarily different from the value that the consumer
    obtains.</p>

<p> This problem is somewhat similar to wanting to express a guarantee 
    that the callback returned from the following function always returns
    positive values: </p>
    
<pre>
std::function&lt;int()&gt; positive_values();
</pre>

<p> While useful, it is not implementable in the current model for contract
    support in 
    <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2900r8.pdf"
       title="Joshua Berne, Timur Doumler, Andrzej Krzemieński et al., &ldquo;Contracts for C++&rdquo;">[P2900R8]</a>. 
    In the current model, we need to have a clear single place where the
    implementation can evaluate the contract assertion expressing the guarantee.
    Even if it was somehow implementable, that would be a different kind of
    contract: not a precondition, not a postcondition (it is <em>not</em> what
    the call to the coroutine's ramp function guarantees to the caller at the
    end of the call). Instead, it is something that the coroutine guarantees
    to unpredictable parties (we do not know how many different actors will
    <code>co_await</code> on the produced <em>Awaitable</em>) at unpredictable
    places. Also, in the case of <code>std::generator</code>, a coroutine need
    not produce an <em>Awaitable</em> at all.</p>

<p> For the same reason that we do not block
    <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2900r8.pdf"
       title="Joshua Berne, Timur Doumler, Andrzej Krzemieński et al., &ldquo;Contracts for C++&rdquo;">[P2900R8]</a>
    even though it is unable to express the contract of
    <code>positive_values()</code> above, we argue that we should not block
    preconditions and postconditions on coroutines only because we cannot express
    the contract of function <code>read()</code> above.
    <p>


<h3><code>co_yield</code>ed values</h3>


<p> Another expectation is to be able to guarantee that a coroutine
    only yields values that satisfy a certain condition. The question is,
    who is the beneficiary of this guarantee? The real consumer of the 
    yielded value is function <code>yield_value</code> on the coroutine's 
    promise object. One might be tempted to express the guarantee as a 
    precondition of <code>yield_value</code>, but that would likely be wrong:
    the same promise type can be used by different coroutines that might want 
    to guarantee different properties for their yielded values.
    </p>
    
<p> The next problem would be that <code>yield_value</code> can do different 
    things with the value it obtains: it can discard the value; or change it:
    the coroutine might be yielding positive values, but the generator interface
    on the other end might be returning negative values to users.
    </p>

<p> A guarantee useful to end users would require a cooperation between the
    coroutine body and the implementation of the promise type.</p>
    
<p> In any case, we do think that the lack of these features should block the
    addition of precondition and postcondition support to coroutines.</p>    



<h2>Proposal</h2>


<p> We propose that preconditions on coroutines be allowed. Their evaluation is
    sequenced after the function parameters are initialized, and before
<ul>
  <li> the potential allocation of a coroutine frame 
       <a href="http://eel.is/c++draft/dcl.fct.def.coroutine#9">[dcl.fct.def.coroutine]/9</a>,</li>
  <li> the initialization of the coroutine promise object
       <a href="http://eel.is/c++draft/dcl.fct.def.coroutine#5.7">[dcl.fct.def.coroutine]/5.7</a>.</li>
</ul>

<p> Parameter names referenced in the precondition predicate
    refer to the original parameters before the move to the coroutine frame.</p>

<p> We propose that postconditions on coroutines be allowed, and have the
    following properties.</p>

<ul>
    <li>The program is ill-formed when a coroutine postcondition odr-uses a
        non-reference function parameter.</li>
    <li>Postcondition evaluation is sequenced after the value, if any, has been
         returned from the ramp function to the caller, and before the function
         parameters (which are moved-from at that time) have been destroyed. </li>
    <li>The postcondition evaluation is unsequenced with respect to the termination
         of the evaluation of the coroutine body and the destruction of its
         automatic variables.</li>
</ul>



<h2>Implementability</h2>



<p> Currently the only compiler to implement contracts and coroutines is GCC. 
    It implements the <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0542r5.html"
       title="G. Dos Reis, J. D. Garcia, J. Lakos, A. Meredith, N. Myers, B. Stroustrup, &ldquo;Support for contract based programming in C++&rdquo;">[P0542R5]</a>
    version of contracts.
    </p>

<p> The implementation in trunk implements <code>[[assert: _]]</code>
    and <code>[[pre: _]]</code> as proposed in this paper.
    Here is a working example in Compiler Explorer:
    <a href="https://godbolt.org/z/x5bTW5W6o">https://godbolt.org/z/x5bTW5W6o</a>.
    </p>

<p> The implementation of <code>[[post: _]]</code> differs from the proposed
    semantics in one aspect: postconditions are allowed to odr-use non-reference
    function parameters, which results in the assertion expressions observing
    the moved-from state of the parameters.   
    </p>
    
<p> The GCC implementation puts the runtime checks for pre- and post-conditions
    inside the ramp function.  This reflects that the current GCC implementation
    for contracts is callee-only.  On-going work to prototype virtual function
    handling is thought to be adaptable to general caller-side contracts and to
    be compatible with coroutines without any special action.
    </p>


<h2>Acknowledgments</h2>


<p> Joshua Berne, Lewis Baker, Tom Honermann and Timur Doumler offered useful
    feedback and improved the quality of the paper.</p>


<h2>References</h2>


<ul>
<li>[P0542R5] &mdash; G. Dos Reis, J. D. Garcia, J. Lakos, A. Meredith, N. Myers, B. Stroustrup,
    "Support for contract based programming in C++", <br>
    (<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0542r5.html">"https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0542r5.html"</a>).
    </li>
    <!--
    <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0542r5.html"
       id="G. Dos Reis, J. D. Garcia, J. Lakos, A. Meredith, N. Myers, B. Stroustrup, &ldquo;Support for contract based programming in C++&rdquo;">[P0542R5]</a>
    -->

<li>[P2461R1] — Gašper Ažman, Caleb Sunstrum, Bronek Kozicki, "Closure-Based Syntax for Contracts" <br>
    (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2461r1.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2461r1.pdf</a>).
    </li>
    <!--
    <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2461r1.pdf"
       title="Gašper Ažman, Caleb Sunstrum, Bronek Kozicki, &ldquo;Closure-Based Syntax for Contracts&rdquo;">[P2461R1]</a>
    -->	
      
<li>[P2900R8] &mdash; Joshua Berne, Timur Doumler, Andrzej Krzemieński et al.,
    "Contracts for C++", <br>
    (<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2900r8.pdf">"https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2900r8.pdf"</a>).
    </li>
    <!--
    <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2900r8.pdf"
       title="Joshua Berne, Timur Doumler, Andrzej Krzemieński et al., &ldquo;Contracts for C++&rdquo;">[P2900R8]</a>
    -->
</ul>



</body></html>
